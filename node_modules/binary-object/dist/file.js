"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileSource = exports.FileSink = void 0;
const tslib_1 = require("tslib");
const fs_1 = tslib_1.__importDefault(require("fs"));
class FileSink {
    constructor(fd) {
        this.fd = fd;
    }
    write(byte) {
        fs_1.default.writeSync(this.fd, Buffer.from([byte]));
    }
    writeBatch(bytes) {
        fs_1.default.writeSync(this.fd, Buffer.from(bytes));
    }
    writeBuffer(buffer, offset, byteLength) {
        fs_1.default.writeSync(this.fd, buffer, offset, byteLength);
    }
    writeString(string, encoding) {
        fs_1.default.writeSync(this.fd, string, null, encoding);
    }
    close() {
        fs_1.default.closeSync(this.fd);
    }
    static fromFile(file, flags = 'a') {
        fs_1.default.writeFileSync(file, '');
        const fd = fs_1.default.openSync(file, flags);
        return new FileSink(fd);
    }
}
exports.FileSink = FileSink;
let buffer = Buffer.alloc(1);
class FileSource {
    constructor(fd) {
        this.fd = fd;
        this.position = 0;
    }
    read() {
        // console.log('read from', this.position)
        fs_1.default.readSync(this.fd, buffer, 0, 1, this.position);
        this.position++;
        return buffer[0];
    }
    /**
     * may be pooled and shared
     * */
    readBatch(byteLength) {
        // console.log('read', byteLength, 'bytes from', this.position)
        if (buffer.length < byteLength) {
            buffer = Buffer.alloc(byteLength);
        }
        fs_1.default.readSync(this.fd, buffer, 0, byteLength, this.position);
        this.position += byteLength;
        return buffer;
    }
    /**
     * must be offset 0 and with enough length
     *
     * will not auto resize
     * */
    readBuffer(byteLength, buffer) {
        // console.log('read', byteLength, 'bytes from', this.position)
        fs_1.default.readSync(this.fd, buffer, 0, byteLength, this.position);
        this.position += byteLength;
    }
    readString(byteLength, encoding) {
        const buffer = this.readBatch(byteLength);
        return buffer.slice(0, byteLength).toString(encoding);
    }
    close() {
        fs_1.default.closeSync(this.fd);
    }
    static fromFile(file, flags = 'r') {
        const fd = fs_1.default.openSync(file, flags);
        return new FileSource(fd);
    }
}
exports.FileSource = FileSource;
//# sourceMappingURL=file.js.map