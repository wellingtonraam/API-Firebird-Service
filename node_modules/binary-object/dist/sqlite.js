"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SqliteValueSource = exports.SqliteObjectSource = exports.makeSqliteSourceOptions = exports.SqliteValueSink = exports.SqliteObjectSink = exports.makeSqliteSinkOptions = void 0;
const better_sqlite3_schema_1 = require("better-sqlite3-schema");
const pipe_1 = require("./pipe");
function makeSqliteSinkOptions(db, schema, options) {
    return {
        insertRowFn: better_sqlite3_schema_1.makeInsertRowFnFromSchema(db, schema),
        close: (options === null || options === void 0 ? void 0 : options.autoClose) ? () => db.close() : undefined,
    };
}
exports.makeSqliteSinkOptions = makeSqliteSinkOptions;
class SqliteObjectSink extends pipe_1.Sink {
    constructor(options) {
        super();
        this.insertRowFn = options.insertRowFn;
        if (options.close) {
            this.close = options.close;
        }
    }
    close() {
        // noop
    }
    write(data) {
        this.insertRowFn(data);
    }
    static create(options) {
        const { file, schema, mode } = options;
        const db = better_sqlite3_schema_1.createDB({ file, mode });
        return new SqliteObjectSink({
            insertRowFn: better_sqlite3_schema_1.makeInsertRowFnFromSchema(db, schema),
            close: () => db.close(),
        });
    }
}
exports.SqliteObjectSink = SqliteObjectSink;
class SqliteValueSink extends SqliteObjectSink {
    write(data) {
        const value = JSON.stringify(data);
        super.write({ value });
    }
}
exports.SqliteValueSink = SqliteValueSink;
function makeSqliteSourceOptions(db, schema, options) {
    return {
        selectRowFn: better_sqlite3_schema_1.makeSelectRowFnFromSchema(db, schema),
        countRowsFn: () => better_sqlite3_schema_1.countRows(db, schema.table),
        close: (options === null || options === void 0 ? void 0 : options.autoClose) ? () => db.close() : undefined,
    };
}
exports.makeSqliteSourceOptions = makeSqliteSourceOptions;
class SqliteObjectSource extends pipe_1.Source {
    constructor(options) {
        super();
        this.offset = 0;
        this.selectRow = options.selectRowFn;
        this.countRows = options.countRowsFn;
        if (options.close) {
            this.close = options.close;
        }
    }
    read() {
        const res = this.selectRow(this.offset);
        this.offset++;
        return res;
    }
    *iterator(options) {
        const n = this.countRows();
        while (this.offset < n) {
            yield this.read();
        }
        if (options === null || options === void 0 ? void 0 : options.autoClose) {
            this.close();
        }
    }
    close() {
        // noop
    }
    static create(options) {
        const db = better_sqlite3_schema_1.createDB({ file: options.file });
        const schema = options.schema;
        return new SqliteObjectSource({
            selectRowFn: better_sqlite3_schema_1.makeSelectRowFnFromSchema(db, schema),
            countRowsFn: () => better_sqlite3_schema_1.countRows(db, schema.table),
            close: () => db.close(),
        });
    }
}
exports.SqliteObjectSource = SqliteObjectSource;
class SqliteValueSource extends SqliteObjectSource {
    read() {
        const value = super.read().value;
        return JSON.parse(value);
    }
}
exports.SqliteValueSource = SqliteValueSource;
//# sourceMappingURL=sqlite.js.map