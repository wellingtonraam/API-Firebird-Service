"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContinuousCompressJsonSource = exports.ContinuousCompressJsonSink = void 0;
const compress_json_1 = require("compress-json");
const memory_1 = require("compress-json/dist/memory");
const pipe_1 = require("./pipe");
const utils_1 = require("./utils");
function createSinkMemory(sink) {
    return {
        cache: memory_1.makeInMemoryCache(),
        keyCount: 0,
        store: {
            add(value) {
                if (value === null) {
                    sink.write('k|');
                }
                else {
                    sink.write(value);
                }
            },
            forEach(cb) {
                throw new Error('not supported');
            },
            toArray() {
                throw new Error('not supported');
            },
        },
    };
}
function encode(sink, memory, data) {
    if (data === null) {
        sink.write('k|');
        return;
    }
    const key = compress_json_1.addValue(memory, data, undefined);
    sink.write('k|' + key);
}
/** @deprecated in favour of unique-value.ts for better better disk-efficiency and speed */
class ContinuousCompressJsonSink extends pipe_1.Sink {
    constructor(sink) {
        super();
        this.sink = sink;
        this.memory = createSinkMemory(this.sink);
    }
    write(data) {
        encode(this.sink, this.memory, data);
    }
    close() {
        this.sink.close();
    }
}
exports.ContinuousCompressJsonSink = ContinuousCompressJsonSink;
function decodeSource(source, values) {
    for (;;) {
        const data = source.read();
        if (data.startsWith('k|')) {
            const key = data.substr(2);
            if (key === '') {
                return null;
            }
            return compress_json_1.decode(values, key);
        }
        values.push(data);
    }
}
class ContinuousCompressJsonSource extends pipe_1.Source {
    constructor(source) {
        super();
        this.source = source;
        this.values = [];
    }
    read() {
        return decodeSource(this.source, this.values);
    }
    *iterator(options) {
        for (;;) {
            try {
                yield this.read();
            }
            catch (e) {
                if (e.toString() === 'Error: ' + utils_1.Errors.End) {
                    return;
                }
                throw e;
            }
        }
    }
    close() {
        this.source.close();
    }
}
exports.ContinuousCompressJsonSource = ContinuousCompressJsonSource;
//# sourceMappingURL=continuous-compress-json.js.map