"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SchemaSource = exports.SchemaSink = exports.Types = void 0;
const pipe_1 = require("./pipe");
const utils_1 = require("./utils");
exports.Types = {
    Array: 1,
    Schema: 2,
    Object: 3,
};
utils_1.checkUniqueTypes(exports.Types);
function getSchemaId(sink, schemas, data) {
    const keys = Object.keys(data);
    const key = JSON.stringify(keys);
    if (schemas.has(key)) {
        return schemas.get(key);
    }
    const id = schemas.size;
    schemas.set(key, id);
    keys.push(exports.Types.Schema);
    sink.write(keys);
    return id;
}
function encodeMap(sink, schemas, data) {
    const res = new Map();
    for (const entry of data) {
        const key = encode(sink, schemas, entry[0]);
        const value = encode(sink, schemas, entry[1]);
        res.set(key, value);
    }
    return res;
}
function encodeSet(sink, schemas, data) {
    const res = new Set();
    for (const entry of data) {
        const value = encode(sink, schemas, entry);
        res.add(value);
    }
    return res;
}
function encodeArray(sink, schemas, data) {
    const n = data.length;
    const res = new Array(n);
    for (let i = 0; i < n; i++) {
        res[i] = encode(sink, schemas, data[i]);
    }
    res.push(exports.Types.Array);
    return res;
}
function encodeObject(sink, schemas, data) {
    const schemaId = getSchemaId(sink, schemas, data);
    const values = Object.values(data).map(value => encode(sink, schemas, value));
    values.push(schemaId, exports.Types.Object);
    return values;
}
function encode(sink, schemas, data) {
    if (data === null || typeof data !== 'object') {
        return data;
    }
    if (data instanceof Date) {
        return data;
    }
    if (Buffer.isBuffer(data)) {
        return data;
    }
    if (data instanceof Map) {
        return encodeMap(sink, schemas, data);
    }
    if (data instanceof Set) {
        return encodeSet(sink, schemas, data);
    }
    if (Array.isArray(data)) {
        return encodeArray(sink, schemas, data);
    }
    // really json object
    return encodeObject(sink, schemas, data);
}
class SchemaSink extends pipe_1.Sink {
    constructor(sink) {
        super();
        this.sink = sink;
        this.schemas = new Map();
    }
    write(data) {
        data = encode(this.sink, this.schemas, data);
        this.sink.write(data);
    }
    close() {
        this.sink.close();
    }
}
exports.SchemaSink = SchemaSink;
function decodeObject(source, schemas, data) {
    const schemaId = data.pop();
    if (schemaId >= schemas.length) {
        console.error('unknown schema:', { schemaId, has: schemas.length });
        throw new Error('unknown schema');
    }
    const keys = schemas[schemaId];
    const n = keys.length;
    if (n !== data.length) {
        console.error('invalid schema data:', { keys: n, values: data.length });
        throw new Error('invalid schema data');
    }
    const values = data.map(data => decode(source, schemas, data));
    const res = {};
    for (let i = 0; i < n; i++) {
        res[keys[i]] = values[i];
    }
    return res;
}
function decodeSchema(source, schemas, data) {
    const type = data.pop();
    switch (type) {
        case exports.Types.Array:
            return data.map(data => decode(source, schemas, data));
        case exports.Types.Schema:
            schemas.push(data);
            return decode(source, schemas, source.read());
        case exports.Types.Object:
            return decodeObject(source, schemas, data);
    }
}
function decodeMap(source, schemas, data) {
    const res = new Map();
    for (const entry of data) {
        const key = decode(source, schemas, entry[0]);
        const value = decode(source, schemas, entry[1]);
        res.set(key, value);
    }
    return res;
}
function decodeSet(source, schemas, data) {
    const res = new Set();
    for (const entry of data) {
        const value = decode(source, schemas, entry);
        res.add(value);
    }
    return res;
}
function decode(source, schemas, data) {
    if (data === null || typeof data !== 'object') {
        return data;
    }
    if (data instanceof Date) {
        return data;
    }
    if (Buffer.isBuffer(data)) {
        return data;
    }
    if (data instanceof Map) {
        return decodeMap(source, schemas, data);
    }
    if (data instanceof Set) {
        return decodeSet(source, schemas, data);
    }
    if (Array.isArray(data)) {
        return decodeSchema(source, schemas, data);
    }
    // really json object
    console.error('unsupported data:', data);
    throw new Error('unsupported data');
}
class SchemaSource extends pipe_1.Source {
    constructor(source) {
        super();
        this.source = source;
        this.schemas = [];
    }
    read() {
        const data = this.source.read();
        return decode(this.source, this.schemas, data);
    }
    *iterator(options) {
        for (const data of this.source.iterator(options)) {
            yield decode(this.source, this.schemas, data);
        }
    }
    close() {
        this.source.close();
    }
}
exports.SchemaSource = SchemaSource;
//# sourceMappingURL=schema.js.map