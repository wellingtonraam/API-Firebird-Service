"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BinaryObjectSource = exports.decodeUtf8String = exports.decodeBuffer = exports.decodeNumberOrEnd = exports.decodeNumber = exports.BinaryObjectSink = exports.encodeUtf8String = exports.encodeBuffer = exports.encodeNumber = exports.Types = void 0;
const number_1 = require("./number");
const pipe_1 = require("./pipe");
const utils_1 = require("./utils");
exports.Types = {
    Undefined: 0,
    Null: 1,
    True: 2,
    False: 3,
    BigInt64BE: 4,
    BigUInt64BE: 5,
    Zero: 6,
    Negative: 7,
    NaN: 8,
    Infinity: 9,
    Byte: 10,
    UInt16BE: 11,
    UInt32BE: 12,
    UInt64BE: 13,
    FloatBE: 14,
    DoubleBE: 15,
    Fraction: 16,
    BinaryString: 17,
    Utf8Function: 18,
    Utf8Symbol: 19,
    DateUInt64BE: 20,
    Map: 21,
    Set: 22,
    Buffer: 23,
    Array: 24,
    Object: 25,
    End: 26,
};
utils_1.checkUniqueTypes(exports.Types);
/**
 * == byteSize ==
 * int16:  2
 * int32:  4
 * int64:  8
 * float:  4
 * double: 8
 *
 * offset: 1 (preserve first byte in buffer)
 * */
const numberBuffer = Buffer.alloc(1 + 8);
function encodeUInt64BE(sink, type, data) {
    numberBuffer[0] = type;
    numberBuffer.writeBigUInt64BE(BigInt(data), 1);
    sink.writeBuffer(numberBuffer, 0, 1 + 8);
}
function encodeUFloat(sink, data) {
    /* float */
    numberBuffer.writeFloatBE(data, 1);
    if (numberBuffer.readFloatBE(1) === data) {
        numberBuffer[0] = exports.Types.FloatBE;
        sink.writeBuffer(numberBuffer, 0, 1 + 4);
        return;
    }
    /* double */
    numberBuffer.writeDoubleBE(data, 1);
    if (numberBuffer.readDoubleBE(1) === data) {
        numberBuffer[0] = exports.Types.DoubleBE;
        sink.writeBuffer(numberBuffer, 0, 1 + 8);
        return;
    }
    /* rational number */
    const frac = number_1.fraction(data);
    sink.write(exports.Types.Fraction);
    encodeNumber(sink, frac[0]);
    encodeNumber(sink, frac[1]);
}
function encodeUInt(sink, data) {
    if (data < Math.pow(2, 8)) {
        numberBuffer[0] = exports.Types.Byte;
        numberBuffer[1] = data;
        sink.writeBuffer(numberBuffer, 0, 1 + 1);
        return;
    }
    if (data < Math.pow(2, 16)) {
        numberBuffer[0] = exports.Types.UInt16BE;
        numberBuffer.writeUInt16BE(data, 1);
        sink.writeBuffer(numberBuffer, 0, 1 + 2);
        return;
    }
    if (data < Math.pow(2, 32)) {
        numberBuffer[0] = exports.Types.UInt32BE;
        numberBuffer.writeUInt32BE(data, 1);
        sink.writeBuffer(numberBuffer, 0, 1 + 4);
        return;
    }
    encodeUInt64BE(sink, exports.Types.UInt64BE, data);
}
function encodeNumber(sink, data) {
    if (data === 0) {
        sink.write(exports.Types.Zero);
        return;
    }
    if (Number.isNaN(data)) {
        sink.write(exports.Types.NaN);
        return;
    }
    if (data < 0) {
        sink.write(exports.Types.Negative);
        encodeNumber(sink, -data);
        return;
    }
    if (!Number.isFinite(data)) {
        sink.write(exports.Types.Infinity);
        return;
    }
    if (Number.isInteger(data)) {
        encodeUInt(sink, data);
        return;
    }
    encodeUFloat(sink, data);
}
exports.encodeNumber = encodeNumber;
function encodeBuffer(sink, data) {
    const byteLength = data.byteLength;
    encodeNumber(sink, byteLength);
    sink.writeBuffer(data, 0, byteLength);
}
exports.encodeBuffer = encodeBuffer;
function encodeBinaryString(sink, data) {
    const buffer = Buffer.from(data, 'binary');
    encodeBuffer(sink, buffer);
}
function encodeUtf8String(sink, data) {
    const buffer = Buffer.from(data, 'utf8');
    encodeBuffer(sink, buffer);
}
exports.encodeUtf8String = encodeUtf8String;
function encodeBigInt(sink, data) {
    if (data >= 0) {
        numberBuffer[0] = exports.Types.BigUInt64BE;
        numberBuffer.writeBigUInt64BE(data, 1);
    }
    else {
        numberBuffer[0] = exports.Types.BigInt64BE;
        numberBuffer.writeBigInt64BE(data, 1);
    }
    sink.writeBuffer(numberBuffer, 0, 1 + 8);
}
function encodeSymbol(sink, data) {
    if (data === utils_1.End) {
        sink.write(exports.Types.End);
        return;
    }
    const key = Symbol.keyFor(data);
    if (key === undefined) {
        console.error('unknown symbol key:', data);
        throw new Error('symbol key not found');
    }
    sink.write(exports.Types.Utf8Symbol);
    encodeUtf8String(sink, key);
}
function encodeMap(sink, data) {
    sink.write(exports.Types.Map);
    encodeNumber(sink, data.size);
    for (const entry of data) {
        encode(sink, entry[0]);
        encode(sink, entry[1]);
    }
}
function encodeSet(sink, data) {
    sink.write(exports.Types.Set);
    encode(sink, data.size);
    for (const datum of data) {
        encode(sink, datum);
    }
}
function encodeArray(sink, data) {
    sink.write(exports.Types.Array);
    const n = data.length;
    encode(sink, n);
    // use indexed-for-loop to not-skip empty entries
    for (let i = 0; i < n; i++) {
        encode(sink, data[i]);
    }
}
function encodeObject(sink, data) {
    sink.write(exports.Types.Object);
    const entries = Object.entries(data);
    const n = entries.length;
    encodeNumber(sink, n);
    // use indexed-for-loop to skip empty check (speed up)
    for (let i = 0; i < n; i++) {
        const entry = entries[i];
        encodeUtf8String(sink, entry[0]);
        encode(sink, entry[1]);
    }
}
function encode(sink, data) {
    switch (typeof data) {
        case 'undefined':
            sink.write(exports.Types.Undefined);
            break;
        case 'object':
            if (data === null) {
                sink.write(exports.Types.Null);
                break;
            }
            if (data instanceof Date) {
                encodeUInt64BE(sink, exports.Types.DateUInt64BE, data.getTime());
                break;
            }
            if (Buffer.isBuffer(data)) {
                sink.write(exports.Types.Buffer);
                encodeBuffer(sink, data);
                break;
            }
            if (data instanceof Map) {
                encodeMap(sink, data);
                break;
            }
            if (data instanceof Set) {
                encodeSet(sink, data);
                break;
            }
            if (Array.isArray(data)) {
                encodeArray(sink, data);
                break;
            }
            encodeObject(sink, data);
            break;
        case 'boolean':
            sink.write(data ? exports.Types.True : exports.Types.False);
            break;
        case 'number':
            encodeNumber(sink, data);
            break;
        case 'string':
            sink.write(exports.Types.BinaryString);
            encodeBinaryString(sink, data);
            break;
        case 'function':
            sink.write(exports.Types.Utf8Function);
            encodeUtf8String(sink, data.toString());
            break;
        case 'symbol':
            encodeSymbol(sink, data);
            break;
        case 'bigint':
            encodeBigInt(sink, data);
            break;
        default:
            if (data === utils_1.End) {
                sink.write(exports.Types.End);
                break;
            }
            console.error('unsupported data type:', data);
            throw new Error('unsupported data type');
    }
}
/**
 * support full set of javascript objects
 * including Buffer, Map, Set and Date
 *
 * but it is much slower than BinaryJsonSink, which only support JSON values
 * */
class BinaryObjectSink extends pipe_1.Sink {
    constructor(sink) {
        super();
        this.sink = sink;
    }
    write(data) {
        encode(this.sink, data);
    }
    close() {
        encode(this.sink, utils_1.End);
        this.sink.close();
    }
}
exports.BinaryObjectSink = BinaryObjectSink;
function decodeUInt64BE(source) {
    source.readBuffer(8, numberBuffer);
    const data = numberBuffer.readBigUInt64BE();
    const number = Number(data);
    return number;
}
function decodeNumber(source) {
    const data = decode(source);
    if (typeof data !== 'number') {
        console.error('invalid data, expect number, got:', data);
        throw new Error('invalid data');
    }
    return data;
}
exports.decodeNumber = decodeNumber;
function decodeNumberOrEnd(source) {
    const data = decode(source);
    if (data === utils_1.End || typeof data === 'number') {
        return data;
    }
    console.error('invalid data, expect number, got:', data);
    throw new Error('invalid data');
}
exports.decodeNumberOrEnd = decodeNumberOrEnd;
function decodeBuffer(source) {
    const byteLength = decodeNumber(source);
    // cannot object the buffer from pool, because the consumer should be be impacted by pool object reuse
    const buffer = Buffer.alloc(byteLength);
    source.readBuffer(byteLength, buffer);
    return buffer;
}
exports.decodeBuffer = decodeBuffer;
function decodeFraction(source) {
    const a = decodeNumber(source);
    const b = decodeNumber(source);
    return a / b;
}
function decodeBinaryString(source) {
    const byteLength = decodeNumber(source);
    return source.readString(byteLength, 'binary');
}
function decodeUtf8String(source) {
    const byteLength = decodeNumber(source);
    return source.readString(byteLength, 'utf8');
}
exports.decodeUtf8String = decodeUtf8String;
// tslint:disable-next-line:ban-types
function decodeUtf8Function(source) {
    const data = decodeUtf8String(source);
    // FIXME use specific parsing to prevent XSS
    // tslint:disable-next-line:no-eval
    const func = eval('(' + data + ')');
    const type = typeof func;
    if (type !== 'function') {
        console.error('invalid binary data, expected function, got:', type);
        throw new Error('invalid binary data');
    }
    return func;
}
function decodeMap(source) {
    const n = decodeNumber(source);
    const data = new Map();
    for (let i = 0; i < n; i++) {
        const key = decode(source);
        const value = decode(source);
        data.set(key, value);
    }
    return data;
}
function decodeSet(source) {
    const n = decodeNumber(source);
    const data = new Set();
    for (let i = 0; i < n; i++) {
        const value = decode(source);
        data.add(value);
    }
    return data;
}
function decodeArray(source) {
    const n = decodeNumber(source);
    const data = new Array(n);
    for (let i = 0; i < n; i++) {
        const value = decode(source);
        data[i] = value;
    }
    return data;
}
function decodeObject(source) {
    const n = decodeNumber(source);
    const data = {};
    for (let i = 0; i < n; i++) {
        const key = decodeUtf8String(source);
        const value = decode(source);
        data[key] = value;
    }
    return data;
}
function decode(source) {
    const type = source.read();
    switch (type) {
        case exports.Types.Undefined:
            return undefined;
        case exports.Types.Null:
            return null;
        case exports.Types.True:
            return true;
        case exports.Types.False:
            return false;
        case exports.Types.BigInt64BE:
            return source.readBatch(8).readBigInt64BE();
        case exports.Types.BigUInt64BE:
            return source.readBatch(8).readBigUInt64BE();
        case exports.Types.Zero:
            return 0;
        case exports.Types.Negative:
            return -decode(source);
        case exports.Types.NaN:
            return Number.NaN;
        case exports.Types.Infinity:
            return 1 / 0;
        case exports.Types.Byte:
            return source.read();
        case exports.Types.UInt16BE:
            return source.readBatch(2).readUInt16BE();
        case exports.Types.UInt32BE:
            return source.readBatch(4).readUInt32BE();
        case exports.Types.UInt64BE:
            return Number(source.readBatch(8).readBigUInt64BE());
        case exports.Types.FloatBE:
            return Number(source.readBatch(4).readFloatBE());
        case exports.Types.DoubleBE:
            return Number(source.readBatch(8).readDoubleBE());
        case exports.Types.Fraction:
            return decodeFraction(source);
        case exports.Types.BinaryString:
            return decodeBinaryString(source);
        case exports.Types.Utf8Function:
            return decodeUtf8Function(source);
        case exports.Types.Utf8Symbol:
            return Symbol.for(decodeUtf8String(source));
        case exports.Types.DateUInt64BE:
            return new Date(decodeUInt64BE(source));
        case exports.Types.Map:
            return decodeMap(source);
        case exports.Types.Set:
            return decodeSet(source);
        case exports.Types.Buffer:
            return decodeBuffer(source);
        case exports.Types.Array:
            return decodeArray(source);
        case exports.Types.Object:
            return decodeObject(source);
        case exports.Types.End:
            return utils_1.End;
        default:
            console.error('unknown binary data type:', type);
            console.error('next:', source.readString(100, 'utf8'));
            throw new Error('unknown binary data type');
    }
}
/**
 * support full set of javascript objects
 * including Buffer, Map, Set and Date
 *
 * but it is much slower than BinaryJsonSource, which only support JSON values
 * */
class BinaryObjectSource extends pipe_1.Source {
    constructor(source) {
        super();
        this.source = source;
    }
    read() {
        return decode(this.source);
    }
    close() {
        this.source.close();
    }
    *iterator(options) {
        for (;;) {
            const data = this.read();
            if (data === utils_1.End) {
                if (options === null || options === void 0 ? void 0 : options.autoClose) {
                    this.close();
                }
                return;
            }
            yield data;
        }
    }
}
exports.BinaryObjectSource = BinaryObjectSource;
//# sourceMappingURL=binary-object.js.map