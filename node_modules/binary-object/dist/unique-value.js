"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UniqueValueSource = exports.UniqueValueSink = void 0;
/**
 * current only support undefined and primitive json data types
 *
 * supported:
 *   - undefined
 *   - null
 *   - string
 *   - number
 *   - array
 *   - object
 *   - boolean
 *
 * not supported:
 *   - Map
 *   - Set
 *   - Date
 *   - Symbol
 *   - bigint
 *   e.t.c.
 * (doesn't support Map, Set, Date, Symbol, bigint, e.t.c.)
 * */
const pipe_1 = require("./pipe");
const utils_1 = require("./utils");
const base_62_1 = require("./utils/base-62");
const WORDS = {
    array: 'a',
    object: 'o',
    value: 'v',
    emit: 'e',
    pop: 'p',
    null: 'n',
    undefined: 'u',
    true: 't',
    false: 'f',
};
utils_1.checkUniqueTypes(WORDS);
function writeLine(context, line) {
    const linesKeys = context.linesKeys;
    if (linesKeys.has(line)) {
        return linesKeys.get(line);
    }
    const key = linesKeys.size;
    linesKeys.set(line, key);
    context.sink.write(line);
    return key;
}
function encode(context, value) {
    switch (value) {
        case null:
            return writeLine(context, WORDS.null);
        case undefined:
            return writeLine(context, WORDS.undefined);
        case true:
            return writeLine(context, WORDS.true);
        case false:
            return writeLine(context, WORDS.false);
    }
    if (Array.isArray(value)) {
        const values = value.map(value => base_62_1.int_to_str(encode(context, value)));
        return writeLine(context, WORDS.array + values.join(','));
    }
    if (typeof value === 'object') {
        const keys = Object.keys(value).map((key) => base_62_1.int_to_str(encode(context, key)));
        const values = Object.values(value).map((value) => base_62_1.int_to_str(encode(context, value)));
        return writeLine(context, WORDS.object + [...keys, ...values].join(','));
    }
    return writeLine(context, WORDS.value + JSON.stringify(value));
}
class UniqueValueSink extends pipe_1.Sink {
    constructor(sink) {
        super();
        this.sink = sink;
        // line -> key
        this.linesKeys = new Map();
    }
    write(data) {
        const key = encode(this, data);
        if (key === this.linesKeys.size - 1) {
            this.sink.write(WORDS.pop);
        }
        else {
            this.sink.write(WORDS.emit + base_62_1.int_to_str(key));
        }
    }
    close() {
        this.sink.close();
    }
}
exports.UniqueValueSink = UniqueValueSink;
function decode(context, line) {
    switch (line) {
        case WORDS.null:
            return null;
        case WORDS.undefined:
            return undefined;
        case WORDS.true:
            return true;
        case WORDS.false:
            return false;
    }
    const type = line[0];
    const data = line.substring(1);
    switch (type) {
        case WORDS.array: {
            const lines = context.lines;
            const values = data
                .split(',')
                .map(key => decode(context, lines.get(base_62_1.str_to_int(key))));
            return values;
        }
        case WORDS.object: {
            const lines = context.lines;
            const keyValues = data
                .split(',')
                .map(key => decode(context, lines.get(base_62_1.str_to_int(key))));
            const n = keyValues.length / 2;
            const object = {};
            for (let i = 0; i < n; i++) {
                const key = keyValues[i];
                const value = keyValues[i + n];
                object[key] = value;
            }
            return object;
        }
        case WORDS.value:
            return JSON.parse(data);
        default: {
            console.error('invalid line:', { type, line });
            throw new Error('invalid line');
        }
    }
}
class UniqueValueSource extends pipe_1.Source {
    constructor(source) {
        super();
        this.source = source;
        this.lines = new Map();
    }
    read() {
        if (!this.generator) {
            this.generator = this.iterator({ autoClose: false });
        }
        const res = this.generator.next();
        if (res.done) {
            throw new Error(utils_1.Errors.End);
        }
        return res.value;
    }
    *iterator(options) {
        const lines = this.lines;
        for (const line of this.source.iterator(options)) {
            const key = lines.size;
            if (line === WORDS.pop) {
                const lastKey = key - 1;
                const lastLine = lines.get(lastKey);
                yield decode(this, lastLine);
                continue;
            }
            const type = line[0];
            if (type === WORDS.emit) {
                const dataKey = base_62_1.str_to_int(line.substring(1));
                const dataLine = lines.get(dataKey);
                yield decode(this, dataLine);
                continue;
            }
            lines.set(key, line);
        }
    }
    close() {
        this.source.close();
    }
}
exports.UniqueValueSource = UniqueValueSource;
//# sourceMappingURL=unique-value.js.map