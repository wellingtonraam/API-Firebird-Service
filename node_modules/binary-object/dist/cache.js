"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CacheSource = exports.CacheSink = void 0;
/**
 * a simplified (and pluggable) version of unique-value
 * */
const pipe_1 = require("./pipe");
const base_62_1 = require("./utils/base-62");
const WORDS = {
    cache: 'c',
    key: 'k',
    value: 'v',
};
class CacheSink extends pipe_1.Sink {
    constructor(sink, options) {
        super();
        this.sink = sink;
        this.values = new Map();
        this.shouldCache = options.shouldCache;
        this.encode = options.encode || (data => JSON.stringify(data));
    }
    write(data) {
        if (!this.shouldCache(data)) {
            this.sink.write(WORDS.value + this.encode(data));
            return;
        }
        if (this.values.has(data)) {
            const key = this.values.get(data);
            this.sink.write(WORDS.key + base_62_1.int_to_str(key));
            return;
        }
        const key = this.values.size;
        this.values.set(data, key);
        this.sink.write(WORDS.cache + this.encode(data));
    }
    close() {
        this.sink.close();
    }
}
exports.CacheSink = CacheSink;
function decode(context, line) {
    const word = line[0];
    const string = line.substring(1);
    switch (word) {
        case WORDS.value:
            return context.decode(string);
        case WORDS.key: {
            const key = base_62_1.str_to_int(string);
            return context.values[key];
        }
        case WORDS.cache: {
            const data = context.decode(string);
            context.values.push(data);
            return data;
        }
        default:
            console.error({ word, data: string });
            throw new Error('unknown word');
    }
}
class CacheSource extends pipe_1.Source {
    constructor(source, options) {
        super();
        this.source = source;
        this.values = [];
        this.decode = (options === null || options === void 0 ? void 0 : options.decode) || (string => JSON.parse(string));
    }
    close() {
        this.source.close();
    }
    read() {
        const line = this.source.read();
        return decode(this, line);
    }
    *iterator(options) {
        for (const line of this.source.iterator(options)) {
            yield decode(this, line);
        }
    }
}
exports.CacheSource = CacheSource;
//# sourceMappingURL=cache.js.map