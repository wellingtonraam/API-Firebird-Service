"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.iterateRows = exports.makeSelectJoin = exports.makeSelectRefFieldArray = exports.countRows = exports.makeGetRefValueFnFromSchema = exports.makeSelectRefFieldSql = exports.makeSelectRowFnFromSchema = exports.forEach = exports.insertArrayField = exports.makeSchemaScanner = exports.isInt = exports.toSqliteDataType = exports.makeAutoAddFieldMapRowFn = exports.addField = exports.makeTableInfo = exports.removeAllIndices = exports.removeIndices = exports.getTables = exports.getIndices = exports.getTableFields = exports.makeInsertRefSqls = exports.makeDeduplicatedInsertRowFnFromSchema = exports.makeInsertRowFnFromSchema = exports.createDB = exports.delDBFile = void 0;
const tslib_1 = require("tslib");
const better_sqlite3_helper_1 = tslib_1.__importDefault(require("better-sqlite3-helper"));
const cache_1 = require("./utils/cache");
const function_1 = require("./utils/function");
function delDBFile(file) {
    const fs = require('fs');
    const files = [file, file + '-shm', file + '-wal'];
    files.forEach(file => {
        if (fs.existsSync(file)) {
            fs.unlinkSync(file);
        }
    });
}
exports.delDBFile = delDBFile;
function createDB(options) {
    const file = options.file;
    if (options.mode === 'overwrite') {
        delDBFile(file);
    }
    delete options.mode;
    return better_sqlite3_helper_1.default(Object.assign({ path: file, migrate: false }, options));
}
exports.createDB = createDB;
function makeInsertRowFnFromSchema(db, schema) {
    autoCreateTable(db, schema);
    autoCreateIndex(db, schema);
    let insertRowFn = makeInsertRowFn(db, schema.table);
    if (schema.autoAddField) {
        const table = makeTableInfo(db, schema.table);
        insertRowFn = function_1.chain(makeAutoAddFieldMapRowFn(db, table), insertRowFn);
    }
    if (schema.refFields) {
        const refFields = toRefSchemas(schema).map(refSchema => makeInsertRefField(db, refSchema));
        insertRowFn = function_1.chain(makeInsertRefFieldsMapRowFn(refFields), insertRowFn);
    }
    if (schema.skipFields) {
        insertRowFn = function_1.chain(makeSkipFieldsMapRowFn(schema.skipFields), insertRowFn);
    }
    const whitelistFields = getWhitelistFields(schema);
    if (whitelistFields) {
        insertRowFn = function_1.chain(makeWhitelistFieldsMapRowFn(whitelistFields), insertRowFn);
    }
    if (!(schema === null || schema === void 0 ? void 0 : schema.inplaceUpdate)) {
        insertRowFn = function_1.chain(cloneRowFn, insertRowFn);
    }
    return insertRowFn;
}
exports.makeInsertRowFnFromSchema = makeInsertRowFnFromSchema;
function getWhitelistFields(schema) {
    if (!schema.whitelistFields) {
        return;
    }
    if (Array.isArray(schema.whitelistFields)) {
        return schema.whitelistFields;
    }
    if (!schema.fields) {
        return;
    }
    return [...Object.keys(schema.fields), ...toRefIdFieldNames(schema)];
}
const defaultIdFieldSuffix = '_id';
function toRefIdFieldNames(schema) {
    var _a;
    return (((_a = schema.refFields) === null || _a === void 0 ? void 0 : _a.map(field => typeof field === 'string'
        ? field + (schema.idFieldSuffix || defaultIdFieldSuffix)
        : field.idField)) || []);
}
const defaultTableFields = {
    id: `integer primary key`,
};
function autoCreateTable(db, schema) {
    if (schema.createTableSql) {
        return db.exec(schema.createTableSql);
    }
    if (!schema.autoCreateTable) {
        return;
    }
    const fields = schema.fields || defaultTableFields;
    toRefIdFieldNames(schema).forEach(field => (fields[field] = 'integer'));
    const fieldsSql = Object.entries(fields)
        .map(entry => entry.join(' '))
        .join(',');
    const sql = `create table if not exists "${schema.table}" (${fieldsSql})`;
    db.exec(sql);
}
function autoCreateIndex(db, schema) {
    if (schema.createIndexSql) {
        return db.exec(schema.createIndexSql);
    }
}
function makeInsertRowFn(db, table) {
    return row => {
        return db.insert(table, row);
    };
}
function makeDeduplicatedInsertRowFn(options, insertRowFn) {
    const deduplicateField = options.deduplicateField;
    const idField = options.idField;
    const select = options.select;
    return row => {
        const fieldData = row[deduplicateField];
        const matchedRow = select.get(fieldData);
        if (matchedRow) {
            return matchedRow[idField];
        }
        return insertRowFn(row);
    };
}
function makeDeduplicatedInsertRowFnFromSchema(db, schema, insertRowFn) {
    const idField = schema.idField;
    const deduplicateField = schema.deduplicateField;
    const select = db.prepare(`select "${idField}" from "${schema.table}" where "${deduplicateField}" = ?`);
    const deduplicatedInsertRowFn = makeDeduplicatedInsertRowFn({
        select,
        idField,
        deduplicateField,
    }, insertRowFn);
    const cache = toCache(schema);
    if (!cache) {
        return deduplicatedInsertRowFn;
    }
    return row => {
        const fieldData = row[deduplicateField];
        return cache.get(fieldData, () => deduplicatedInsertRowFn(row));
    };
}
exports.makeDeduplicatedInsertRowFnFromSchema = makeDeduplicatedInsertRowFnFromSchema;
function cloneRowFn(row) {
    return Object.assign({}, row);
}
function makeWhitelistFieldsMapRowFn(whitelistFields) {
    return (row) => {
        const res = {};
        whitelistFields.forEach(field => (res[field] = row[field]));
        return res;
    };
}
function makeSkipFieldsMapRowFn(skipFields) {
    return (row) => {
        skipFields.forEach(field => delete row[field]);
        return row;
    };
}
function makeInsertRefFieldsMapRowFn(refFields) {
    return (row) => {
        refFields.forEach(refField => {
            const field = refField.field;
            if (!(field in row)) {
                return;
            }
            const data = row[field];
            const id = refField.getRefIdFn(refField, data);
            delete row[field];
            row[refField.idField] = id;
        });
        return row;
    };
}
function toRefSchemas(schema) {
    return (schema.refFields || []).map(refField => toRefSchema(refField, schema));
}
function toRefSchema(refField, schema) {
    var _a;
    if (typeof refField !== 'string') {
        return refField;
    }
    const field = refField;
    const idField = field + (schema.idFieldSuffix || defaultIdFieldSuffix);
    const refFieldSchema = {
        field,
        idField,
        autoCreateTable: schema.autoCreateTable,
        autoCreateIndex: schema.autoCreateIndex,
    };
    if ((_a = schema.cacheFields) === null || _a === void 0 ? void 0 : _a.includes(field)) {
        refFieldSchema.cache = schema.cache;
        refFieldSchema.cacheSize = schema.cacheSize;
    }
    return refFieldSchema;
}
function makeInsertRefField(db, schema) {
    const field = schema.field;
    const sqls = makeInsertRefSqls(db, schema);
    return {
        field,
        idField: schema.idField,
        select: sqls.select,
        insert: sqls.insert,
        getRefIdFn: makeGetRefIdFn(schema),
    };
}
function makeGetRefIdFn(refField) {
    const cache = toCache(refField);
    if (cache) {
        return makeCachedGetRefIdFn(cache);
    }
    return getRefId;
}
function createRefTableIfNotExist(db, field, idField) {
    db.exec(`create table if not exists "${field}" (
  "${idField}" integer primary key,
  ${field} text
);`);
}
function createRefIndexIfNotExist(db, field) {
    db.exec(`create unique index if not exists "${field}_idx" on "${field}" ("${field}")`);
}
function makeInsertRefSqls(db, schema) {
    const field = schema.field;
    const idField = schema.idField;
    if (schema.autoCreateTable) {
        createRefTableIfNotExist(db, field, idField);
    }
    if (schema.autoCreateIndex) {
        createRefIndexIfNotExist(db, field);
    }
    const select = db.prepare(`select "${idField}" from "${field}" where "${field}" = ? limit 1`);
    const insert = db.prepare(`insert into "${field}" ("${field}") values (?)`);
    return { select, insert, idField };
}
exports.makeInsertRefSqls = makeInsertRefSqls;
function getRefId(refSqls, fieldData) {
    const row = refSqls.select.get(fieldData);
    if (row) {
        return row[refSqls.idField];
    }
    return +refSqls.insert.run(fieldData).lastInsertRowid;
}
function makeCachedGetRefIdFn(cache) {
    return (refSqls, fieldData) => cache.get(fieldData, () => getRefId(refSqls, fieldData));
}
function getTableFields(db, table) {
    return db.prepare(`PRAGMA table_info("${table}")`).all();
}
exports.getTableFields = getTableFields;
function getIndices(db, table) {
    return db
        .prepare(`select * from sqlite_master where type = 'index' and tbl_name = ?`)
        .all(table);
}
exports.getIndices = getIndices;
function getTables(db) {
    return db.prepare(`select * from sqlite_master where type = 'table'`).all();
}
exports.getTables = getTables;
function removeIndices(db, table) {
    getIndices(db, table).forEach(row => {
        db.exec(`drop index if exists "${row.name}"`);
    });
}
exports.removeIndices = removeIndices;
function removeAllIndices(db) {
    db.prepare(`select name from sqlite_master where type = 'index'`)
        .all()
        .forEach(row => {
        db.exec(`drop index if exists "${row.name}"`);
    });
}
exports.removeAllIndices = removeAllIndices;
function makeTableInfo(db, table) {
    const fields = {};
    getTableFields(db, table).forEach(column => (fields[column.name] = column.type));
    return {
        table,
        fields,
    };
}
exports.makeTableInfo = makeTableInfo;
function addField(db, table, field, type) {
    const sql = `alter table "${table.table}" add ${field} ${type};`;
    db.exec(sql);
    table.fields[field] = type;
}
exports.addField = addField;
function makeAutoAddFieldMapRowFn(db, table) {
    return (row) => {
        Object.keys(row).forEach(field => {
            if (field in table.fields) {
                return;
            }
            const type = toSqliteDataType(row[field]);
            addField(db, table, field, type);
        });
        return row;
    };
}
exports.makeAutoAddFieldMapRowFn = makeAutoAddFieldMapRowFn;
function toSqliteDataType(fieldData) {
    switch (typeof fieldData) {
        case 'string':
            return 'text';
        case 'boolean':
            return 'boolean';
        case 'object':
            return 'json';
        case 'number': {
            return isInt(fieldData) ? 'integer' : 'real';
        }
    }
    return 'blob';
}
exports.toSqliteDataType = toSqliteDataType;
function isInt(number) {
    const int = parseInt(number, 10);
    return int === +number;
}
exports.isInt = isInt;
function makeSchemaScanner() {
    const fields = {};
    const addRowFn = (row) => {
        Object.keys(row).forEach(field => {
            if (field in fields) {
                return;
            }
            const type = toSqliteDataType(row[field]);
            fields[field] = type;
        });
    };
    return { fields, addRowFn };
}
exports.makeSchemaScanner = makeSchemaScanner;
function toCache(options) {
    if (options.cache) {
        return options.cache;
    }
    if (options.cacheSize) {
        return cache_1.newCache({ resetSize: options.cacheSize });
    }
}
/**
 * @remark the rows will be updated in-place
 * */
function insertArrayField(rows, idFields, insertRowFn) {
    rows === null || rows === void 0 ? void 0 : rows.forEach(row => {
        Object.assign(row, idFields);
        insertRowFn(row);
    });
}
exports.insertArrayField = insertArrayField;
function forEach(rows, fn) {
    rows === null || rows === void 0 ? void 0 : rows.forEach(fn);
}
exports.forEach = forEach;
function makeSelectRowFnFromSchema(db, schema) {
    const select = db.prepare(`select * from "${schema.table}" limit 1 offset ?`);
    let selectRowFn = offset => select.get(offset);
    if (schema.refFields) {
        const refFields = toRefSchemas(schema).map(refSchema => makeSelectRefField(db, refSchema));
        selectRowFn = function_1.chain(selectRowFn, makeSelectRefFieldsMapRowFn(refFields));
    }
    return selectRowFn;
}
exports.makeSelectRowFnFromSchema = makeSelectRowFnFromSchema;
function makeSelectRefField(db, schema) {
    const field = schema.field;
    const idField = schema.idField;
    return {
        field,
        idField,
        select: makeSelectRefFieldSql(db, field, idField),
        getRefValueFn: makeGetRefValueFn(schema),
    };
}
function makeSelectRefFieldSql(db, field, idField = field + defaultIdFieldSuffix) {
    return db.prepare(`select "${field}" from "${field}" where "${idField}" = ?`);
}
exports.makeSelectRefFieldSql = makeSelectRefFieldSql;
function makeGetRefValueFnFromSchema(db, schema) {
    const field = schema.field;
    const idField = schema.idField || field + defaultIdFieldSuffix;
    const select = makeSelectRefFieldSql(db, field, idField);
    const getRefValueFn = makeGetRefValueFn(schema);
    return (fieldId) => getRefValueFn(select, field, fieldId);
}
exports.makeGetRefValueFnFromSchema = makeGetRefValueFnFromSchema;
function makeGetRefValueFn(refField) {
    const cache = toCache(refField);
    if (cache) {
        return makeCachedGetRefValueFn(cache);
    }
    return getRefValue;
}
function getRefValue(select, field, fieldId) {
    return select.get(fieldId)[field];
}
function makeCachedGetRefValueFn(cache) {
    return (select, field, fieldId) => cache.get(fieldId, () => getRefValue(select, field, fieldId));
}
function makeSelectRefFieldsMapRowFn(refFields) {
    return (row) => {
        refFields.forEach(refField => {
            const idField = refField.idField;
            if (!(idField in row)) {
                return;
            }
            const field = refField.field;
            const id = row[idField];
            const fieldValue = refField.getRefValueFn(refField.select, field, id);
            delete row[idField];
            row[field] = fieldValue;
        });
        return row;
    };
}
function countRows(db, table) {
    return db.queryFirstCell(`select count(*) from "${table}"`);
}
exports.countRows = countRows;
function makeSelectRefFieldArray(db, schema) {
    const res = makeSelectJoin(db, Object.assign({ fromTable: schema.table, joinTable: schema.field, joinField: toJoinField(schema) }, schema));
    return res.all;
}
exports.makeSelectRefFieldArray = makeSelectRefFieldArray;
function toJoinField(schema) {
    if ('joinField' in schema) {
        return schema.joinField;
    }
    return schema.field + (schema.idFieldSuffix || defaultIdFieldSuffix);
}
function makeSelectJoin(db, schema) {
    const field = schema.field;
    const joinTable = schema.joinTable;
    const fromTable = schema.fromTable;
    const joinField = schema.joinField;
    const idField = schema.idField;
    const sql = db.prepare(`select "${field}" from "${fromTable}" inner join "${joinTable}" on "${fromTable}"."${joinField}" = "${joinTable}"."${joinField}" where "${idField}" = ?`);
    let all = makeAllSelectJoin(sql, field);
    let get = makeGetSelectJoin(sql, field);
    const cache = toCache(schema);
    if (cache) {
        all = cache.wrapFn(all);
        get = cache.wrapFn(get);
    }
    return {
        sql,
        all,
        get,
    };
}
exports.makeSelectJoin = makeSelectJoin;
function makeGetSelectJoin(sql, field) {
    return (fieldId) => { var _a; return (_a = sql.get(fieldId)) === null || _a === void 0 ? void 0 : _a[field]; };
}
function makeAllSelectJoin(sql, field) {
    return (fieldId) => sql.all(fieldId).map(row => row[field]);
}
function* iterateRows(select, count) {
    for (let i = 0; i < count; i++) {
        yield select(i);
    }
}
exports.iterateRows = iterateRows;
//# sourceMappingURL=helpers.js.map